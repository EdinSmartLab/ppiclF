c-----------------------------------------------------------------------
      subroutine uservp (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      integer e,eg

      e = gllel(eg)

      udiff=0.0
      utrans=0.

      return
      end
c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      ffx = 0.0
      ffy = 0.0
      ffz = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      integer e,eg

      qvol   = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'TOTAL'
#include "ppiclf_user.h"
#include "ppiclf.h"
#include "PPICLF"

      call ppiclf_io_vtu_write('',0)
      call ppiclf_io_vtu_write_bins('',0)
      call ppiclf_io_vtu_write_grd('',0)


      call ppiclf_external_grid_map
      call ppiclf_comm_binned_grid

      call ppiclf_project
      ! test function
c     do ie=1,nelt
c     do k=1,nz1
c     do j=1,ny1
c     do i=1,nx1
c        ppiclf_pro_fld(i,j,k,ie,1) = cos(xm1(i,j,k,ie)*6.28)
c     enddo
c     enddo
c     enddo
c     enddo

      call outpost2(ppiclf_pro_fld(1,1,1,1,PPICLF_P_JPHIP)
     >             ,ppiclf_pro_fld(1,1,1,1,PPICLF_P_JPHIP)
     >             ,ppiclf_pro_fld(1,1,1,1,PPICLF_P_JPHIP)
     >             ,ppiclf_pro_fld(1,1,1,1,PPICLF_P_JPHIP)
     >             ,ppiclf_pro_fld(1,1,1,1,PPICLF_P_JPHIP),1,'ptw')

      call exitt

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,eg)
      include 'SIZE'
      include 'TSTEP'
      include 'NEKUSE'
      include 'INPUT'
      include 'GEOM' 

      ux = 0.0
      uy = 0.0
      uz = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      integer e,eg, eqnum

      ux = 0.
      uy = 0.
      uz = 0.

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
      include 'SIZE'
      include 'TOTAL'

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2
      include 'SIZE'
      include 'TOTAL'
#include "ppiclf_user.h"
#include "ppiclf.h"
#include "PPICLF"

      common /nekmpi/ mid,mp,nekcomm,nekgroup,nekreal

      real rparam(ppiclf_nparam) 

      ppiclf_comm = nekcomm
      ppiclf_nid  = nid
      ppiclf_np   = np

      rparam(1)  = 1           ! use custom values
      rparam(2)  = 1           ! time integration method
      rparam(3)  = 2           ! polynomial order of mesh
      rparam(4)  = 0           ! use 1 for tracers only
      rparam(5)  = 0.1        ! filter width in real units
      rparam(6)  = 4           ! how many grid points to resolve filter over
      rparam(7)  = 1E-2        ! percent decay of Gaussian filter
      rparam(8)  = 1           ! periodic in x (== 0) ! dont do periodic without bounds!!!
      rparam(9)  = 1           ! periodic in y (== 0)
      rparam(10) = 1           ! periodic in z (== 0)
      rparam(11) = 8E-4        ! time step
      rparam(12) = 3           ! problem dimensions

      call init_particles(ppiclf_y,npart)
      call ppiclf_init(rparam,ppiclf_y,npart,0.0) 




      return
      end
!-----------------------------------------------------------------------
      subroutine usrdat3
      return
      end
!-----------------------------------------------------------------------
      subroutine ppiclf_comm_binned_grid
#include "ppiclf_user.h"
#include "ppiclf.h"
#include "PPICLF"

      real ppiclf_xm1bd(PPICLF_LEX,PPICLF_LEY,PPICLF_LEZ,3,PPICLF_LEE)
      common /ppiclf_mesh_orig/ ppiclf_xm1bd


      ! see which bins are in which elements
      ppiclf_neltb = 0
      do ie=1,ppiclf_nee
      do k=1,PPICLF_LEZ
      do j=1,PPICLF_LEY
      do i=1,PPICLF_LEX
         rxval = ppiclf_xm1b(i,j,k,1,ie)
         ryval = ppiclf_xm1b(i,j,k,2,ie)
         rzval = 0.
         if(ppiclf_rparam(12).gt.2) rzval = ppiclf_xm1b(i,j,k,3,ie)

         ppiclf_xm1bd(i,j,k,1,ie) = rxval
         ppiclf_xm1bd(i,j,k,2,ie) = ryval
         ppiclf_xm1bd(i,j,k,3,ie) = rzval

         if (rxval .gt. ppiclf_binb(2)) goto 1233
         if (rxval .lt. ppiclf_binb(1)) goto 1233
         if (ryval .gt. ppiclf_binb(4)) goto 1233
         if (ryval .lt. ppiclf_binb(3)) goto 1233
         if (ppiclf_rparam(12).gt.2 .and. rzval .gt. ppiclf_binb(6)) 
     >      goto 1233
         if (ppiclf_rparam(12).gt.2 .and. rzval .lt. ppiclf_binb(5))
     >      goto 1233

         ii    = floor((rxval-ppiclf_binb(1))/ppiclf_rdxgp) 
         jj    = floor((ryval-ppiclf_binb(3))/ppiclf_rdygp) 
         kk    = floor((rzval-ppiclf_binb(5))/ppiclf_rdzgp) 
         if (ppiclf_rparam(12).lt.3) kk = 0
         !if (ii .eq. ppiclf_ndxgp) ii = ppiclf_ndxgp - 1
         !if (jj .eq. ppiclf_ndygp) jj = ppiclf_ndygp - 1
         !if (kk .eq. ppiclf_ndzgp) kk = ppiclf_ndzgp - 1
         ndum  = ii + ppiclf_ndxgp*jj + ppiclf_ndxgp*ppiclf_ndygp*kk
         nrank = ndum

c        if (ii .eq. ppiclf_ndxgp-1) write(6,*) rxval,ppiclf_ndxgp

c        if (ppiclf_binb(3) .gt. ryval)
c    >      write(6,*) ryval,ppiclf_binb(3),jj
         if (ii .lt. 0 .or. ii .gt. ppiclf_ndxgp-1) then
c           write(6,*) 'Bounds here:',ppiclf_binb
c           write(6,*) 'Failed here:',rxval,ryval,rzval
            goto 1233
         endif
         if (jj .lt. 0 .or. jj .gt. ppiclf_ndygp-1) then
c           write(6,*) 'Bounds here:',ppiclf_binb
c           write(6,*) 'Failed here:',rxval,ryval,rzval
            goto 1233
         endif
         if (kk .lt. 0 .or. kk .gt. ppiclf_ndzgp-1) then
c           write(6,*) 'Bounds here:',ppiclf_binb
c           write(6,*) 'Failed here:',rxval,ryval,rzval
            goto 1233
         endif

         ppiclf_neltb = ppiclf_neltb + 1
         if(ppiclf_neltb .gt. PPICLF_LEE) then
           write(6,*) 'increase PPICLF_LEE', ppiclf_nid, ppiclf_neltb
           return
           !call exitt
         endif

         ppiclf_er_map(1,ppiclf_neltb) = ie
         ppiclf_er_map(2,ppiclf_neltb) = ppiclf_nid
         ppiclf_er_map(3,ppiclf_neltb) = ndum
         ppiclf_er_map(4,ppiclf_neltb) = nrank
         ppiclf_er_map(5,ppiclf_neltb) = nrank
         ppiclf_er_map(6,ppiclf_neltb) = nrank

         if (ppiclf_neltb .gt. 1) then
         do il=1,ppiclf_neltb-1
            if (ppiclf_er_map(1,il) .eq. ie) then
            if (ppiclf_er_map(4,il) .eq. nrank) then
               ppiclf_neltb = ppiclf_neltb - 1
               goto 1233
            endif
            endif
         enddo
         endif
 1233 continue
      enddo
      enddo
      enddo
      enddo

      ! Should re-add what I had here before... remove mapping from
      ! other "external" routine in this file too....

      nxyz = PPICLF_LEX*PPICLF_LEY*PPICLF_LEZ
      do ie=1,ppiclf_neltb
       iee = ppiclf_er_map(1,ie)
       call copy(ppiclf_xm1b(1,1,1,1,ie),ppiclf_xm1bd(1,1,1,1,iee),nxyz)
       call copy(ppiclf_xm1b(1,1,1,2,ie),ppiclf_xm1bd(1,1,1,2,iee),nxyz)
       call copy(ppiclf_xm1b(1,1,1,3,ie),ppiclf_xm1bd(1,1,1,3,iee),nxyz)
      enddo

      ppiclf_neltbb = ppiclf_neltb
      do ie=1,ppiclf_neltbb
         call icopy(ppiclf_er_maps(1,ie),ppiclf_er_map(1,ie)
     >             ,PPICLF_LRMAX)
      enddo


      nl   = 0
      nii  = PPICLF_LRMAX
      njj  = 6
      nxyz = PPICLF_LEX*PPICLF_LEY*PPICLF_LEZ
      nrr  = nxyz*3
      nkey = 3
      call fgslib_crystal_tuple_transfer(i_cr_hndl,ppiclf_neltb
     >       ,PPICLF_LEE,ppiclf_er_map,nii,partl,nl,ppiclf_xm1b,nrr,njj)
      call fgslib_crystal_tuple_sort    (i_cr_hndl,ppiclf_neltb
     >       ,ppiclf_er_map,nii,partl,nl,ppiclf_xm1b,nrr,nkey,1)


      do ie=1,ppiclf_neltb
      do k=1,PPICLF_LEZ
      do j=1,PPICLF_LEY
      do i=1,PPICLF_LEX
         rxval = ppiclf_xm1b(i,j,k,1,ie)
         ryval = ppiclf_xm1b(i,j,k,2,ie)
         rzval = 0.
         if(ppiclf_rparam(12).gt.2) rzval = ppiclf_xm1b(i,j,k,3,ie)
         
         ii    = floor((rxval-ppiclf_binb(1))/ppiclf_rdxgp) 
         jj    = floor((ryval-ppiclf_binb(3))/ppiclf_rdygp) 
         kk    = floor((rzval-ppiclf_binb(5))/ppiclf_rdzgp) 
         if (ppiclf_rparam(12).eq.2) kk = 0
         !if (ii .eq. ppiclf_ndxgp) ii = ppiclf_ndxgp - 1
         !if (jj .eq. ppiclf_ndygp) jj = ppiclf_ndygp - 1
         !if (kk .eq. ppiclf_ndzgp) kk = ppiclf_ndzgp - 1
         ndum  = ii + ppiclf_ndxgp*jj + ppiclf_ndxgp*ppiclf_ndygp*kk

         ppiclf_modgp(i,j,k,ie,1) = ii
         ppiclf_modgp(i,j,k,ie,2) = jj
         ppiclf_modgp(i,j,k,ie,3) = kk
         ppiclf_modgp(i,j,k,ie,4) = ndum
   
      enddo
      enddo
      enddo
      enddo

      do ie=1,ppiclf_neltb
         ppiclf_xerange(1,1,ie) = 
     >      ppiclf_vlmin(ppiclf_xm1b(1,1,1,1,ie),nxyz)
         ppiclf_xerange(2,1,ie) = 
     >      ppiclf_vlmax(ppiclf_xm1b(1,1,1,1,ie),nxyz)
         ppiclf_xerange(1,2,ie) = 
     >      ppiclf_vlmin(ppiclf_xm1b(1,1,1,2,ie),nxyz)
         ppiclf_xerange(2,2,ie) = 
     >      ppiclf_vlmax(ppiclf_xm1b(1,1,1,2,ie),nxyz)
         ppiclf_xerange(1,3,ie) = 
     >      ppiclf_vlmin(ppiclf_xm1b(1,1,1,3,ie),nxyz)
         ppiclf_xerange(2,3,ie) = 
     >      ppiclf_vlmax(ppiclf_xm1b(1,1,1,3,ie),nxyz)

         ilow  = 
     >     floor((ppiclf_xerange(1,1,ie) - ppiclf_binb(1))/ppiclf_rdxgp)
         ihigh = 
     >     floor((ppiclf_xerange(2,1,ie) - ppiclf_binb(1))/ppiclf_rdxgp)
         jlow  = 
     >     floor((ppiclf_xerange(1,2,ie) - ppiclf_binb(3))/ppiclf_rdygp)
         jhigh = 
     >     floor((ppiclf_xerange(2,2,ie) - ppiclf_binb(3))/ppiclf_rdygp)
         klow  = 
     >     floor((ppiclf_xerange(1,3,ie) - ppiclf_binb(5))/ppiclf_rdzgp)
         khigh = 
     >     floor((ppiclf_xerange(2,3,ie) - ppiclf_binb(5))/ppiclf_rdzgp)
         if (ppiclf_rparam(12).lt.3) then
            klow = 0
            khigh = 0
         endif

         ppiclf_el_map(1,ie) = ilow  + ppiclf_ndxgp*jlow  
     >                            + ppiclf_ndxgp*ppiclf_ndygp*klow
         ppiclf_el_map(2,ie) = ihigh + ppiclf_ndxgp*jhigh 
     >                            + ppiclf_ndxgp*ppiclf_ndygp*khigh
         ppiclf_el_map(3,ie) = ilow
         ppiclf_el_map(4,ie) = ihigh
         ppiclf_el_map(5,ie) = jlow
         ppiclf_el_map(6,ie) = jhigh
         ppiclf_el_map(7,ie) = klow
         ppiclf_el_map(8,ie) = khigh
      enddo

      return
      end

!-----------------------------------------------------------------------
      subroutine ppiclf_external_grid_map
      include 'SIZE'
      include 'TOTAL'
#include "ppiclf_user.h"
#include "ppiclf.h"
#include "PPICLF"

      nxyz = PPICLF_LEX*PPICLF_LEY*PPICLF_LEZ

      ppiclf_nee = nelt
      do ie=1,ppiclf_nee
         call copy(ppiclf_xm1b(1,1,1,1,ie), xm1(1,1,1,ie),nxyz)
         call copy(ppiclf_xm1b(1,1,1,2,ie), ym1(1,1,1,ie),nxyz)
         call copy(ppiclf_xm1b(1,1,1,3,ie), zm1(1,1,1,ie),nxyz)
      enddo

      return
      end

!-----------------------------------------------------------------------
      subroutine init_particles(y,npart)
#include "ppiclf_user.h"
#include "ppiclf.h"
#include "PPICLF"

      real      y(*)
      real      pi
      real      ran2
      external  ran2

      npart   = 50       ! particles/rank to distribute
      dp      = 0.01   ! particle diameter
      rhop    = 3307.327 ! particle density
      rdum    = ran2(-1-ppiclf_nid) ! initialize random number generator
      PI      = 4.D0*DATAN(1.D0)

      do i=1,npart
         ! set initial conditions for solution
         j = PPICLF_LRS*(i-1)
         y(PPICLF_JX +j) = 0.1 + 0.8*ran2(2)
         y(PPICLF_JY +j) = 0.7 + 0.2*ran2(2)
         y(PPICLF_JZ +j) = 0.1 + 0.8*ran2(2)
         y(PPICLF_JVX+j) = 0.0
         y(PPICLF_JVY+j) = 0.0
         y(PPICLF_JVZ+j) = 0.0
      
         ! set some initial particle properties
         ppiclf_rprop(PPICLF_R_JRHOP,i) = rhop
         ppiclf_rprop(PPICLF_R_JDP  ,i) = dp
         ppiclf_rprop(PPICLF_R_JVOLP,i) = pi/6.0
     >                                  *ppiclf_rprop(PPICLF_R_JDP,i)**3
      enddo

      return
      end
!-----------------------------------------------------------------------
      FUNCTION ran2(idum)
      INTEGER idum,IM1,IM2,IMM1,IA1,IA2,IQ1,IQ2,IR1,IR2,NTAB,NDIV 
      REAL ran2,AM,EPS,RNMX
      PARAMETER (IM1=2147483563,IM2=2147483399,AM=1./IM1,IMM1=IM1-1,
     $        IA1=40014,IA2=40692,IQ1=53668,IQ2=52774,IR1=12211,
     $        IR2=3791,NTAB=32,NDIV=1+IMM1/NTAB,EPS=1.2e-7,RNMX=1.-EPS)
c Long period (> 2 ! 1018 ) random number generator of L’Ecuyer with 
c Bays-Durham shuffle and added safeguards. Returns a uniform random deviate 
c between 0.0 and 1.0 (exclusive of the endpoint values). 
c Call with idum a negative integer to initialize; thereafter, do not alter 
c idum between successive deviates in a sequence. RNMX should approximate the 
c largest floating value that is less than 1.
      INTEGER idum2,j,k,iv(NTAB),iy
      SAVE iv,iy,idum2
      DATA idum2/123456789/, iv/NTAB*0/, iy/0/
      if (idum.le.0) then 
         idum1=max(-idum,1) 
         idum2=idum1
         do j=NTAB+8,1,-1
            k=idum1/IQ1
            idum1=IA1*(idum1-k*IQ1)-k*IR1 
            if (idum1.lt.0) idum1=idum1+IM1 
            if (j.le.NTAB) iv(j)=idum1
         enddo
         iy=iv(1) 
      endif
      k=idum1/IQ1 
      idum1=IA1*(idum1-k*IQ1)-k*IR1
      if (idum1.lt.0) idum1=idum1+IM1 
      k=idum2/IQ2 
      idum2=IA2*(idum2-k*IQ2)-k*IR2 
      if (idum2.lt.0) idum2=idum2+IM2 
      j=1+iy/NDIV
      iy=iv(j)-idum2
      iv(j)=idum1 
      if(iy.lt.1)iy=iy+IMM1 
      ran2=min(AM*iy,RNMX)
      return
      END
c----------------------------------------------------------------------
