c-----------------------------------------------------------------------
      subroutine uservp (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      integer e,eg

      e = gllel(eg)

      udiff=0.0
      utrans=0.

      return
      end
c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
#include "PPICLF"

      ie = gllel(ieg)

      ffx = ppiclf_pro_fld(ix,iy,iz,ie,PPICLF_P_JFX)
      ffy = ppiclf_pro_fld(ix,iy,iz,ie,PPICLF_P_JFY)
      
      rdum = 1./utrans
      rdum = rdum/(1.-ppiclf_pro_fld(ix,iy,iz,ie,PPICLF_P_JPHIP))

      ffx = ffx*rdum
      ffy = ffy*rdum

      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      integer e,eg

      qvol   = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine userchk
      include 'SIZE'
      include 'TOTAL'
#include "PPICLF"

      ! External from Nek5000 to be used in ppiclf_user.f
      real fld_to_interp(PPICLF_LEX,PPICLF_LEY,PPICLF_LEZ,PPICLF_LEE,
     >                   PPICLF_LRP_INT)
      common /interp_fld_nek/ fld_to_interp
      ! External from Nek5000 to be used in ppiclf_user.f

      do ie=1,nelt
      do k=1,lz1
      do j=1,ly1
      do i=1,lx1
         fld_to_interp(i,j,k,ie,1) 
     >                 = ppiclf_pro_fld(i,j,k,ie,PPICLF_P_JPHIP)
         fld_to_interp(i,j,k,ie,2) 
     >                 = vx(i,j,k,ie)
         fld_to_interp(i,j,k,ie,3) 
     >                 = vy(i,j,k,ie)
      enddo
      enddo
      enddo
      enddo

      call ppiclf_solve_IntegrateParticle(istep,iostep,dt,time
     >                                   ,ppiclf_y,ppiclf_ydot)

      if (mod(istep,iostep) .eq. 0)
     >   call outpost2(ppiclf_pro_fld(1,1,1,1,PPICLF_P_JFX)
     >                ,ppiclf_pro_fld(1,1,1,1,PPICLF_P_JFY)
     >                ,ppiclf_pro_fld(1,1,1,1,PPICLF_P_JPHIP)
     >                ,ppiclf_pro_fld(1,1,1,1,PPICLF_P_JPHIP)
     >                ,ppiclf_pro_fld(1,1,1,1,PPICLF_P_JPHIP),1,'ptw')

      return
      end
c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,eg)
      include 'SIZE'
      include 'TSTEP'
      include 'NEKUSE'
      include 'INPUT'
      include 'GEOM' 

      ux = 0.0
      uy = 2.0
      uz = 0.0

      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      integer e,eg, eqnum

      ux = 0.
      uy = 2.0
      uz = 0.

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
      include 'SIZE'
      include 'TOTAL'

      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat2
      include 'SIZE'
      include 'TOTAL'
#include "PPICLF"

      ! For user implemented collision model
      real ksp,erest
      common /external_user_collsion/ ksp,erest
      ! For user implemented collision model

      common /nekmpi/ mid,mp,nekcomm,nekgroup,nekreal

      ! For user implemented collision model
      ksp      = 10.0
      erest    = 0.1
c     rpi      = 4.0*atan(1.0)
c     rmij1    = rpi/6.0*((1.2E-3)**3)*2500. ! change with diff ic's
c     rmij2    = rpi/6.0*((1.2E-3)**3)*2500. ! change with diff ic's
c     nres     = 20
c     rmij     = 1./(1./rmij2 + 1./rmij2)
c     dt_c_max = sqrt(rmij/ksp*(log(erest)**2 + rpi**2))/nres
c     write(6,*) 'MAX DT FOR COLLISIONS',dt_c_max
      ! For user implemented collision model

      call ppiclf_comm_InitMPI(nekcomm,nid,np)

         call ppiclf_io_ReadParticleVTU("par99999.vtu")
      call ppiclf_solve_InitParticle(1,2,0,ppiclf_npart,ppiclf_y) 

      call ppiclf_solve_InitGaussianFilter(2.4E-3,1E-3,0)
      call ppiclf_comm_InitOverlapMesh(nelt,lx1,ly1,lz1,xm1,ym1,zm1)
      call ppiclf_solve_InitNeighborBin(1.2E-3) ! particle diameter

      call ppiclf_solve_InitWall(       ! bottom wall
     >                 (/-0.022,0.0/),
     >                 (/ 0.022,0.0/),
     >                 (/ 0.0  ,0.0/))
      call ppiclf_solve_InitWall(       ! top wall
     >                 (/-0.022,0.08/),
     >                 (/ 0.022,0.08/),
     >                 (/ 0.0  ,0.0 /))
      call ppiclf_solve_InitPeriodicX(-0.022,0.022)

      return
      end
!-----------------------------------------------------------------------
      subroutine usrdat3
      return
      end
!-----------------------------------------------------------------------
      subroutine userqtl 
      include 'SIZE'
      include 'TOTAL'
#include "PPICLF"

      call qtl_pvol(usrdiv,ppiclf_pro_fld(1,1,1,1,PPICLF_P_JPHIP))

      return
      end
c-----------------------------------------------------------------------
      subroutine qtl_pvol(divin,phipin)
c
c     Computes modified divergence constraint for multiphase dense
c     incompressible flow
c
      include 'SIZE'
      include 'TOTAL'

      common /phig_qtl_blk/ phig_last
      real phig_last(lx1,ly1,lz1,lelt)

      real divin(lx2,ly2,lz2,lelv), phipin(lx1,ly1,lz1,lelt)

      COMMON /SCRNS/ ur(lx1,ly1,lz1,lelt)
     >              ,us(lx1,ly1,lz1,lelt)
     >              ,ut(lx1,ly1,lz1,lelt)
     >              ,phigin(lx1,ly1,lz1,lelt)
     >              ,phig_qtl(lx1,ly1,lz1,lelt)
     >              ,grad_dot(lx1,ly1,lz1,lelt)

      integer icalld
      save    icalld
      data    icalld  /-1/

      icalld = icalld + 1
      nxyze = lx1*ly1*lz1*lelt

      rdt_in = 1./dt

      call rzero(phig_qtl,nxyze)

      if (icalld .eq. 0) then
         call rone(phig_last,nxyze)
         call sub2(phig_last,phipin,nxyze)
      endif

      call rone(phigin,nxyze)
      call sub2(phigin,phipin,nxyze)
      
c     if (icalld .lt. 5) goto 123

      call opgrad(ur,us,ut,phigin)
      call sub3(phig_qtl,phigin,phig_last,nxyze)
      call cmult(phig_qtl,rdt_in,nxyze)
      call vdot3(grad_dot,vx,vy,vz,ur,us,ut,nxyze)
      call add2(phig_qtl,grad_dot,nxyze)
      call invcol2(phig_qtl,phigin,nxyze)
      call chsign(phig_qtl,nxyze)

      call copy(phig_last,phigin,nxyze)

      do ie=1,nelt
         call map12(divin(1,1,1,ie),phig_qtl(1,1,1,ie),ie)
      enddo

      return
      end
c-----------------------------------------------------------------------
